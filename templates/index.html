<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ViEventLog - Viessmann Event Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            min-height: 100vh;
            padding: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .header-link {
            background: rgba(255,255,255,0.05);
            color: #a0a0b0;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 14px;
            transition: all 0.2s;
        }

        .header-link:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-color: rgba(255,255,255,0.2);
        }

        h1 {
            color: #fff;
            font-size: 24px;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 14px;
            color: #a0a0b0;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
        }

        .status-dot.connected {
            background: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            font-size: 14px;
            background: rgba(255,255,255,0.05);
            color: #e0e0e0;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.08);
        }

        select option {
            background: #1e1e2e;
            color: #e0e0e0;
        }

        select optgroup {
            background: #262637;
            color: #fff;
            font-weight: 600;
            font-style: normal;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b41a0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            border-color: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        .events-container {
            background: linear-gradient(135deg, #1e1e2e 0%, #262637 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .events-header {
            background: rgba(0,0,0,0.2);
            padding: 15px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .events-header h2 {
            color: #fff;
        }

        .event-count {
            font-size: 14px;
            color: #a0a0b0;
        }

        .events-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .event-item {
            padding: 15px 30px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: background 0.2s;
            cursor: pointer;
        }

        .event-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .event-item.expanded {
            background: rgba(255,255,255,0.08);
        }

        .event-header {
            display: grid;
            grid-template-columns: 180px 1fr auto;
            gap: 20px;
            align-items: center;
        }

        .event-time {
            font-size: 13px;
            color: #a0a0b0;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .event-type {
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
        }

        .event-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            background: #edf2f7;
            color: #4a5568;
        }

        .event-badge.error {
            background: #fed7d7;
            color: #c53030;
        }

        .event-badge.warning {
            background: #feebc8;
            color: #c05621;
        }

        .event-badge.info {
            background: #bee3f8;
            color: #2c5282;
        }

        .event-badge.status {
            background: #c6f6d5;
            color: #276749;
        }

        .event-badge.fault {
            background: #fed7d7;
            color: #c53030;
        }

        .code-description {
            font-size: 13px;
            color: #b0b0c0;
            margin-top: 4px;
            font-style: italic;
        }

        .device-info {
            font-size: 12px;
            color: #a0a0b0;
            display: inline-block;
            padding: 2px 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-left: 8px;
        }

        .event-details {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
            max-height: 300px;
            overflow-y: auto;
            color: #b0b0c0;
        }

        .event-item.expanded .event-details {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #a0a0b0;
        }

        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(254, 215, 215, 0.1);
            color: #ff6b6b;
            border: 1px solid rgba(197, 48, 48, 0.3);
            padding: 15px 30px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            font-size: 14px;
            width: 200px;
            background: rgba(255,255,255,0.05);
            color: #e0e0e0;
        }

        .no-events {
            text-align: center;
            padding: 60px;
            color: #a0a0b0;
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                max-width: 100%;
            }

            header {
                padding: 15px;
                border-radius: 8px;
            }

            .header-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .header-top > div:last-child {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }

            h1 {
                font-size: 20px;
            }

            .status {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                font-size: 13px;
            }

            .controls {
                padding: 15px;
                gap: 12px;
                border-radius: 8px;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
                width: 100%;
                gap: 5px;
            }

            select, input, .filter-input {
                width: 100%;
                font-size: 16px; /* Prevents zoom on iOS */
            }

            button {
                width: 100%;
                padding: 12px 20px;
                font-size: 15px;
            }

            .timeline-container {
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 15px;
            }

            .timeline-container h2 {
                font-size: 18px;
            }

            .timeline-container p {
                font-size: 11px;
            }

            #timelineControls {
                gap: 6px;
            }

            #timelineControls button {
                padding: 6px 10px;
                font-size: 11px;
                width: auto;
            }

            #timeline {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                min-height: 0;
            }

            /* Fix timeline SVG width for mobile */
            #timeline svg {
                max-width: none;
                height: auto;
            }

            .events-container {
                border-radius: 8px;
            }

            .events-header {
                padding: 12px 15px;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .events-header h2 {
                font-size: 18px;
            }

            .event-count {
                font-size: 13px;
            }

            .events-list {
                max-height: 500px;
            }

            .event-item {
                padding: 12px 15px;
            }

            .event-header {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .event-time {
                font-size: 12px;
            }

            .event-type {
                font-size: 13px;
            }

            .device-info {
                display: block;
                margin: 5px 0;
            }

            .event-badge {
                font-size: 11px;
                padding: 3px 10px;
            }

            .code-description {
                font-size: 12px;
                margin-top: 6px;
            }

            .event-details {
                font-size: 12px;
                max-height: 200px;
                padding: 12px;
            }

            .loading {
                padding: 30px;
            }

            .loading-spinner {
                width: 30px;
                height: 30px;
            }

            .no-events {
                padding: 40px 20px;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 18px;
            }

            .header-top > div:last-child {
                font-size: 12px;
            }

            .header-link {
                padding: 6px 12px;
                font-size: 13px;
            }

            .controls {
                padding: 12px;
            }

            button {
                padding: 10px 16px;
                font-size: 14px;
            }

            #timelineControls button {
                padding: 5px 8px;
                font-size: 10px;
            }

            #saveFiltersBtn, #resetFiltersBtn {
                padding: 5px 8px !important;
                font-size: 10px !important;
            }

            .timeline-container h2 {
                font-size: 16px;
            }

            .event-item {
                padding: 10px 12px;
            }

            .event-type {
                font-size: 12px;
            }

            .event-time {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <h1>ViEventLog</h1>
                <div style="display: flex; gap: 10px;">
                    <a href="/smartclimate" class="header-link">üè† SmartClimate</a>
                    <a href="/vitovent" class="header-link">üå¨Ô∏è Vitovent</a>
                    <a href="/vitocharge" class="header-link">‚ö° Vitocharge</a>
                    <a href="/accounts" class="header-link">‚öôÔ∏è Account-Verwaltung</a>
                    <a href="/apitest" class="header-link">üîß API Test</a>
                </div>
            </div>
            <div class="status">
                <div class="status-indicator">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="statusText">Verbinde...</span>
                </div>
                <div id="lastFetch"></div>
                <div id="deviceInfo"></div>
            </div>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Zeitraum:</label>
                <select id="daysSelect">
                    <option value="0.25">Letzte 6 Stunden</option>
                    <option value="1" selected>Letzte 24 Stunden</option>
                    <option value="3">Letzte 3 Tage</option>
                    <option value="7">Letzte 7 Tage</option>
                    <option value="14">Letzte 14 Tage</option>
                    <option value="30">Letzte 30 Tage</option>
                    <option value="365">Alle</option>
                </select>
            </div>

            <div class="control-group">
                <label>Ger√§t:</label>
                <select id="deviceSelect">
                    <option value="all">Alle Ger√§te</option>
                </select>
            </div>

            <div class="control-group">
                <label>Filter:</label>
                <input type="text" id="filterInput" class="filter-input" placeholder="Event-Typ oder Code filtern...">
            </div>

            <div class="control-group">
                <label>Typ:</label>
                <select id="typeFilter">
                    <option value="all">Alle</option>
                    <option value="status">Status (S-Codes)</option>
                    <option value="fault">Fehler (F-Codes)</option>
                    <option value="active">Aktive Events</option>
                </select>
            </div>

            <button id="refreshBtn" onclick="loadEvents()">
                Aktualisieren
            </button>

            <button id="autoRefreshBtn" onclick="toggleAutoRefresh()">
                Auto-Refresh: Aus
            </button>

            <button id="exportBtn" onclick="exportEvents()" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                üíæ Export Events
            </button>

            <button id="dashboardBtn" onclick="openDashboard()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                üìä Dashboard
            </button>
        </div>

        <!-- Timeline Visualization -->
        <div class="timeline-container" style="background: linear-gradient(to bottom, #1e1e2e 0%, #262637 100%); border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); padding: 24px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1); overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2 style="margin: 0; font-size: 20px; color: #fff; font-weight: 600; display: flex; align-items: center; gap: 10px;">
                        <span style="display: inline-block; width: 4px; height: 20px; background: linear-gradient(to bottom, #667eea, #764ba2); border-radius: 2px;"></span>
                        Event Timeline
                    </h2>
                    <p style="margin: 5px 0 0 14px; font-size: 12px; color: #a0a0b0;">Visualisierung der Betriebszust√§nde</p>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                    <button id="saveFiltersBtn" onclick="saveTimelineFilters()"
                            style="padding: 7px 13px; border: 1px solid rgba(255,255,255,0.3);
                                   background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
                                   color: white; border-radius: 6px; cursor: pointer; font-size: 12px;
                                   font-weight: 500; transition: all 0.2s; display: inline-flex;
                                   align-items: center; gap: 6px; box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);"
                            title="Aktuelle Timeline-Filter-Auswahl im Browser speichern">
                        üíæ Auswahl speichern
                    </button>
                    <button id="resetFiltersBtn" onclick="resetTimelineFilters()"
                            style="padding: 7px 13px; border: 1px solid rgba(255,255,255,0.2);
                                   background: rgba(255,255,255,0.05);
                                   color: #a0a0b0; border-radius: 6px; cursor: pointer; font-size: 12px;
                                   font-weight: 500; transition: all 0.2s; display: inline-flex;
                                   align-items: center; gap: 6px;"
                            title="Timeline-Filter auf Standardwerte zur√ºcksetzen">
                        üîÑ Reset
                    </button>
                    <div id="timelineControls" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <!-- Filter buttons will be added here -->
                    </div>
                </div>
            </div>
            <div id="timeline" style="width: 100%; overflow-x: auto; overflow-y: hidden; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px;"></div>
        </div>

        <div class="events-container">
            <div class="events-header">
                <h2>Events</h2>
                <div class="event-count" id="eventCount">0 Events</div>
            </div>
            <div class="events-list" id="eventsList">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>Lade Events...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        let allEvents = [];
        let installations = {};
        let autoRefreshInterval = null;
        let autoRefreshEnabled = false;

        // Centralized filter state
        let globalFilters = {
            // Zeitraum filter (determines API call AND display for both views)
            days: 1, // Default: Last 24 hours (365, 30, 14, 7, 3, 1)

            // Client-side filters (filter loaded events)
            device: 'all',
            type: 'all',
            search: '',

            // Timeline event type filters
            timelineTypes: {
                'S.123': true,  // W√§rmepumpe Aus
                'S.124': true,  // W√§rmepumpe Vorlaufphase
                'S.125': true,  // W√§rmepumpe Heizen
                'S.125-WARMWATER': true,  // W√§rmepumpe Warmwasserbereitung
                'S.126': true,  // W√§rmepumpe K√ºhlen
                'S.128': true,  // W√§rmepumpe Abtauen
                'S.129': true,  // W√§rmepumpe Nachlaufphase
                'S.112': true,  // Initialisierung 4/3-Wege-Ventil
                'S.113': true,  // 4/3-Wege-Ventil schaltet -> Trinkwasser
                'S.114': true,  // 4/3-Wege-Ventil schaltet -> Heiz-/K√ºhlkreis 1
                'S.115': true,  // 4/3-Wege Ventil Position Trinkwasser
                'S.116': true,  // 4/3-Wege Ventil Position Heiz-/K√ºhlkreis 1
                'S.117': true,  // 4/3-Wege Ventil Position Heiz-/K√ºhlkreis 2
                'S.118': true,  // 4/3-Wege Ventil Position Pufferspeicher
                'S.134': true,  // 4/3-Wege Ventil Leerlauf
                'S.135': true,  // 4/3-Wege Ventil Abtauen
                'S.136': true,  // 4/3-Wege Ventil Raumbeheizung/Raumk√ºhlung
                'S.168': true,  // L√ºftungsbypass offen
                'S.169': true,  // L√ºftungsbypass geschlossen
                'I.121': true,  // Feuchteanbauschalter Heiz-/K√ºhlkreis 1 aktiv
                'I.122': true,  // Feuchteanbauschalter Heiz-/K√ºhlkreis 2 aktiv
                'other': true
            }
        };

        // ========================================
        // HELPER FUNCTIONS
        // ========================================

        /**
         * Format timestamp to local timezone
         * Converts RFC3339/ISO timestamp to browser's local time
         */
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'N/A';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString('de-DE', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch (e) {
                return timestamp;
            }
        }

        function categorizeEvent(event) {
            // Use the category from backend if available
            if (event.codeCategory === 'fault') return 'fault';
            if (event.codeCategory === 'status') return 'status';

            // Fallback to eventType-based categorization
            const eventType = event.eventType || '';
            const errorPatterns = ['error', 'fail', 'fault', 'critical'];
            const warningPatterns = ['warning', 'warn', 'alert'];

            const lowerType = eventType.toLowerCase();

            if (errorPatterns.some(p => lowerType.includes(p))) {
                return 'error';
            } else if (warningPatterns.some(p => lowerType.includes(p))) {
                return 'warning';
            }
            return 'info';
        }

        function formatEventBody(body) {
            if (!body || Object.keys(body).length === 0) {
                return 'Keine Details verf√ºgbar';
            }
            return JSON.stringify(body, null, 2);
        }

        // ========================================
        // FILTER FUNCTIONS
        // ========================================

        /**
         * Apply all client-side filters to events
         * Returns filtered events based on globalFilters state
         */
        function applyFilters(events) {
            let filtered = [...events];

            // Time range filter (apply the days filter client-side as well)
            if (globalFilters.days < 365) {
                const cutoffTime = new Date(Date.now() - globalFilters.days * 24 * 60 * 60 * 1000);
                filtered = filtered.filter(event => {
                    const eventTime = new Date(event.eventTimestamp || event.createdAt);
                    return eventTime >= cutoffTime;
                });
            }

            // Device filter
            if (globalFilters.device !== 'all') {
                filtered = filtered.filter(e => {
                    const deviceKey = `${e.installationId}_${e.deviceId}_${e.modelId}`;
                    return deviceKey === globalFilters.device;
                });
            }

            // Type filter
            if (globalFilters.type !== 'all') {
                filtered = filtered.filter(e => {
                    if (globalFilters.type === 'status') return e.codeCategory === 'status';
                    if (globalFilters.type === 'fault') return e.codeCategory === 'fault';
                    if (globalFilters.type === 'active') return e.active === true;
                    return true;
                });
            }

            // Search filter
            if (globalFilters.search) {
                const searchLower = globalFilters.search.toLowerCase();
                filtered = filtered.filter(e =>
                    e.eventType.toLowerCase().includes(searchLower) ||
                    (e.errorCode && e.errorCode.toLowerCase().includes(searchLower)) ||
                    (e.humanReadable && e.humanReadable.toLowerCase().includes(searchLower)) ||
                    JSON.stringify(e.body).toLowerCase().includes(searchLower)
                );
            }

            // Sort by time (newest first)
            filtered.sort((a, b) => {
                const timeA = new Date(a.eventTimestamp || a.createdAt);
                const timeB = new Date(b.eventTimestamp || b.createdAt);
                return timeB - timeA;
            });

            return filtered;
        }

        /**
         * Update filter state from UI and refresh views
         */
        function updateFiltersFromUI() {
            globalFilters.device = document.getElementById('deviceSelect').value;
            globalFilters.type = document.getElementById('typeFilter').value;
            globalFilters.search = document.getElementById('filterInput').value;
            globalFilters.days = parseFloat(document.getElementById('daysSelect').value);

            // Refresh both views with current data
            refreshViews();
        }

        /**
         * Refresh event list and timeline with current filters
         */
        function refreshViews() {
            const filteredEvents = applyFilters(allEvents);
            renderEvents(filteredEvents);
            renderTimeline(filteredEvents);
        }

        // ========================================
        // RENDERING FUNCTIONS
        // ========================================

        /**
         * Render filtered events in the event list
         * Events are already filtered by applyFilters()
         */
        function renderEvents(filteredEvents) {
            const container = document.getElementById('eventsList');

            // Update count
            document.getElementById('eventCount').textContent = `${filteredEvents.length} Events`;

            if (filteredEvents.length === 0) {
                container.innerHTML = '<div class="no-events">Keine Events gefunden</div>';
                return;
            }

            // Render events
            container.innerHTML = filteredEvents.map((event, index) => {
                const category = categorizeEvent(event);
                let statusIndicator = '';
                if (event.active !== null && event.errorCode) {
                    statusIndicator = event.active
                        ? '<span style="color: #c53030;">‚óè AKTIV</span>'
                        : '<span style="color: #48bb78;">‚óè BEENDET</span>';
                }

                const deviceInfo = `<span class="device-info">${event.modelId || 'Unknown'} - Device ${event.deviceId || '0'}</span>`;

                // Get account info
                let accountInfo = '';
                if (event.accountName && event.accountName !== event.accountId) {
                    accountInfo = `<span class="device-info" style="background: rgba(139, 92, 246, 0.15); border-color: rgba(139, 92, 246, 0.3);">üë§ ${event.accountName}</span>`;
                }

                // Get installation info
                let installationInfo = '';
                if (event.installationId && installations[event.installationId]) {
                    const inst = installations[event.installationId];
                    installationInfo = `<span class="device-info" style="background: rgba(102, 126, 234, 0.15); border-color: rgba(102, 126, 234, 0.3);">üìç ${inst.location}</span>`;
                }

                // Build event type display
                let eventTypeDisplay = event.errorCode ? `<strong>${event.errorCode}</strong>` : event.eventType;

                // Special handling for feature-changed events
                if (event.eventType === 'feature-changed' && event.featureName) {
                    eventTypeDisplay = `<strong>feature-changed</strong>: ${event.featureName}`;
                    if (event.featureValue) {
                        eventTypeDisplay += ` <span style="color: #a0a0b0; font-size: 12px;">(${event.featureValue})</span>`;
                    }
                }

                return `
                    <div class="event-item" onclick="toggleEvent(${index})">
                        <div class="event-header">
                            <div class="event-time">${formatTimestamp(event.eventTimestamp || event.createdAt)}</div>
                            <div class="event-type">
                                ${eventTypeDisplay}
                                ${statusIndicator}
                                ${deviceInfo}
                                ${accountInfo}
                                ${installationInfo}
                                ${event.humanReadable ? `<div class="code-description">${event.humanReadable}</div>` : ''}
                            </div>
                            <div class="event-badge ${category}">${category.toUpperCase()}</div>
                        </div>
                        <div class="event-details" id="details-${index}">
Event Type: ${event.eventType}
${event.featureName ? 'Feature: ' + event.featureName + '\n' : ''}
${event.featureValue ? 'Wert: ' + event.featureValue + '\n' : ''}
${event.errorCode ? 'Error Code: ' + event.errorCode + '\n' : ''}
${event.humanReadable ? 'Bedeutung: ' + event.humanReadable + '\n' : ''}
${event.errorDescription ? 'System-Beschreibung: ' + event.errorDescription + '\n' : ''}
Ger√§t: ${event.modelId || 'Unknown'} (ID: ${event.deviceId || '0'})
Gateway Serial: ${event.gatewaySerial || 'N/A'}

Rohdaten:
${formatEventBody(event.body)}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleEvent(index) {
            const item = document.querySelectorAll('.event-item')[index];
            item.classList.toggle('expanded');
        }

        // ========================================
        // DATA LOADING
        // ========================================

        /**
         * Load events from server based on globalFilters.days
         * Then apply client-side filters and render
         */
        async function loadEvents() {
            const btn = document.getElementById('refreshBtn');
            btn.disabled = true;
            btn.textContent = 'Lade...';

            // Update filter state from UI before loading
            updateFiltersFromUI();

            try {
                const response = await fetch(`/api/events?days=${globalFilters.days}`);
                if (!response.ok) throw new Error('Fehler beim Laden der Events');

                allEvents = await response.json();

                // Load device list first to populate installations
                await updateDeviceList();

                // Apply filters and render both views
                refreshViews();

                // Update last fetch time
                const now = new Date();
                document.getElementById('lastFetch').textContent =
                    `Letzte Aktualisierung: ${now.toLocaleTimeString()}`;

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('eventsList').innerHTML =
                    `<div class="error-message">Fehler beim Laden der Events: ${error.message}</div>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Aktualisieren';
            }
        }

        /**
         * Update device dropdown and installations cache
         * Preserves current selection from globalFilters
         */
        async function updateDeviceList() {
            const deviceSelect = document.getElementById('deviceSelect');

            try {
                // Fetch devices grouped by installation from API
                const response = await fetch('/api/devices');
                const devicesByInstallation = await response.json();

                // Store installation data for timeline use
                installations = {};
                devicesByInstallation.forEach(installation => {
                    installations[installation.installationId] = {
                        description: installation.description,
                        location: installation.location
                    };
                });

                // Update select options
                deviceSelect.innerHTML = '<option value="all">Alle Ger√§te</option>';

                // Add grouped options by installation
                devicesByInstallation.forEach(installation => {
                    // Create optgroup for installation
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `üìç ${installation.description || installation.installationId} - ${installation.location}`;

                    installation.devices.forEach(device => {
                        const option = document.createElement('option');
                        const key = `${installation.installationId}_${device.deviceId}_${device.modelId}`;
                        option.value = key;
                        option.textContent = `${device.modelId} (Device ${device.deviceId})`;
                        optgroup.appendChild(option);
                    });

                    deviceSelect.appendChild(optgroup);
                });

                // Restore selection from globalFilters
                const allOptions = deviceSelect.querySelectorAll('option');
                const optionExists = Array.from(allOptions).some(opt => opt.value === globalFilters.device);
                if (optionExists) {
                    deviceSelect.value = globalFilters.device;
                } else {
                    // If previous selection doesn't exist anymore, reset to 'all'
                    globalFilters.device = 'all';
                    deviceSelect.value = 'all';
                }
            } catch (error) {
                console.error('Error loading devices:', error);
            }
        }

        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                const info = document.getElementById('deviceInfo');

                if (status.connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Verbunden';
                    info.textContent = `Device: ${status.device_id || 'Unknown'}`;
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Nicht verbunden';
                    info.textContent = '';
                }
            } catch (error) {
                console.error('Status error:', error);
            }
        }

        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            autoRefreshEnabled = !autoRefreshEnabled;

            if (autoRefreshEnabled) {
                btn.textContent = 'Auto-Refresh: An';
                btn.style.background = '#10b981';
                autoRefreshInterval = setInterval(loadEvents, 60000); // Every minute
            } else {
                btn.textContent = 'Auto-Refresh: Aus';
                btn.style.background = '#667eea';
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================

        // Filter input - update search filter and refresh views
        document.getElementById('filterInput').addEventListener('input', () => {
            globalFilters.search = document.getElementById('filterInput').value;
            refreshViews();
        });

        // Device filter - update and refresh views
        document.getElementById('deviceSelect').addEventListener('change', () => {
            globalFilters.device = document.getElementById('deviceSelect').value;
            refreshViews();
        });

        // Type filter - update and refresh views
        document.getElementById('typeFilter').addEventListener('change', () => {
            globalFilters.type = document.getElementById('typeFilter').value;
            refreshViews();
        });

        // Days filter - reload from server
        document.getElementById('daysSelect').addEventListener('change', () => {
            globalFilters.days = parseFloat(document.getElementById('daysSelect').value);
            loadEvents();
        });

        // ========================================
        // TIMELINE RENDERING
        // ========================================

        /**
         * Render timeline with already filtered events
         * Events are pre-filtered by applyFilters() (including time range)
         * Timeline only applies event type filter (globalFilters.timelineTypes)
         */
        function renderTimeline(events) {
            const container = document.getElementById('timeline');
            const controlsContainer = document.getElementById('timelineControls');

            if (!events || events.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Keine Events verf√ºgbar</div>';
                return;
            }

            // NOTE: We don't filter events here anymore because valve position events (S.115, S.116, etc.)
            // are needed for the state machine logic even though they don't create their own bars.
            // The filter will be applied later when rendering bars, not when processing state transitions.
            const filteredEvents = events;

            // Setup filter buttons
            const eventTypes = {
                // W√§rmepumpen-Status
                'S.125': { label: 'Heizen', description: 'W√§rmepumpe im Heizbetrieb', color: '#ef4444', gradient: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)', icon: 'üî•' },
                'S.125-WARMWATER': { label: 'WW-Bereitung', description: 'Warmwasserbereitung aktiv', color: '#8b5cf6', gradient: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', icon: 'üöø' },
                'S.126': { label: 'K√ºhlen', description: 'W√§rmepumpe im K√ºhlbetrieb', color: '#06b6d4', gradient: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)', icon: '‚ùÑÔ∏è' },
                'S.128': { label: 'Abtauen', description: 'W√§rmepumpe im Abtaubetrieb', color: '#14b8a6', gradient: 'linear-gradient(135deg, #14b8a6 0%, #0d9488 100%)', icon: 'üíß' },
                'S.123': { label: 'Aus', description: 'W√§rmepumpe ausgeschaltet', color: '#64748b', gradient: 'linear-gradient(135deg, #64748b 0%, #475569 100%)', icon: '‚è∏' },
                'S.124': { label: 'Vorlauf', description: 'W√§rmepumpe Vorlaufphase', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: '‚è´' },
                'S.129': { label: 'Nachlauf', description: 'W√§rmepumpe Nachlaufphase', color: '#3b82f6', gradient: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', icon: '‚è¨' },

                // Ventil-Positionen
                'S.112': { label: 'V-Init', description: 'Ventil initialisiert', color: '#94a3b8', gradient: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', icon: 'üîß' },
                'S.113': { label: 'V schaltet‚ÜíWW', description: 'Ventil schaltet zu Warmwasser', color: '#c084fc', gradient: 'linear-gradient(135deg, #c084fc 0%, #a855f7 100%)', icon: '‚Üí' },
                'S.114': { label: 'V schaltet‚ÜíHK1', description: 'Ventil schaltet zu Heizkreis 1', color: '#fb923c', gradient: 'linear-gradient(135deg, #fb923c 0%, #f97316 100%)', icon: '‚Üí' },
                'S.115': { label: 'V-Position WW', description: 'Ventil in Warmwasser-Position', color: '#a78bfa', gradient: 'linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%)', icon: 'üîÄ' },
                'S.116': { label: 'V-Position HK1', description: 'Ventil in Heizkreis 1 Position', color: '#f97316', gradient: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)', icon: 'üîÄ' },
                'S.117': { label: 'V-Position HK2', description: 'Ventil in Heizkreis 2 Position', color: '#f59e0b', gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', icon: 'üîÄ' },
                'S.118': { label: 'V-Position Puffer', description: 'Ventil in Pufferspeicher-Position', color: '#10b981', gradient: 'linear-gradient(135deg, #10b981 0%, #059669 100%)', icon: 'üîÑ' },
                'S.134': { label: 'V-Leerlauf', description: 'Ventil im Leerlauf', color: '#6b7280', gradient: 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)', icon: '‚≠ï' },
                'S.135': { label: 'V-Abtauen', description: 'Ventil in Abtau-Position', color: '#22d3ee', gradient: 'linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%)', icon: 'üîÄ' },
                'S.136': { label: 'V-Raumheizung', description: 'Ventil in Raumheizungs-Position', color: '#84cc16', gradient: 'linear-gradient(135deg, #84cc16 0%, #65a30d 100%)', icon: 'üè†' },

                // L√ºftung & Bypass
                'S.168': { label: 'Bypass offen', description: 'L√ºftungsbypass ge√∂ffnet', color: '#22c55e', gradient: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', icon: 'üå¨Ô∏è' },
                'S.169': { label: 'Bypass zu', description: 'L√ºftungsbypass geschlossen', color: '#6b7280', gradient: 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)', icon: 'üö´' },

                // Taupunkt/Feuchteschutz
                'I.121': { label: 'Feuchte HK1', description: 'Feuchteanbauschalter Heizkreis 1 aktiv - Taupunkt unterschritten', color: '#fbbf24', gradient: 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)', icon: 'üí¶' },
                'I.122': { label: 'Feuchte HK2', description: 'Feuchteanbauschalter Heizkreis 2 aktiv - Taupunkt unterschritten', color: '#fb923c', gradient: 'linear-gradient(135deg, #fb923c 0%, #f97316 100%)', icon: 'üí¶' }
            };

            controlsContainer.innerHTML = Object.entries(eventTypes).map(([code, info]) => {
                const active = globalFilters.timelineTypes[code] !== false;
                return `
                    <button onclick="toggleTimelineFilter('${code}')"
                            title="${info.description}"
                            style="padding: 7px 13px; border: 1px solid ${active ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.15)'};
                                   background: ${active ? info.gradient : 'rgba(255,255,255,0.05)'};
                                   color: ${active ? 'white' : '#a0a0b0'};
                                   border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;
                                   transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px;
                                   ${active ? 'box-shadow: 0 2px 8px ' + info.color + '40;' : ''}">
                        <span style="font-size: 14px;">${info.icon}</span>
                        ${info.label}
                    </button>
                `;
            }).join('');

            // Sort events by timestamp
            const sortedEvents = [...filteredEvents].sort((a, b) => {
                const aTime = new Date(a.eventTimestamp || a.createdAt);
                const bTime = new Date(b.eventTimestamp || b.createdAt);
                return aTime - bTime;
            });

            if (sortedEvents.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">Keine Events nach Filterung</div>';
                return;
            }

            // Clear container
            container.innerHTML = '';

            // Parse timestamps
            const timeExtent = [
                new Date(sortedEvents[0].eventTimestamp || sortedEvents[0].createdAt),
                new Date(sortedEvents[sortedEvents.length - 1].eventTimestamp || sortedEvents[sortedEvents.length - 1].createdAt)
            ];

            // Group events by device and status code to create state spans
            const lanes = {};
            sortedEvents.forEach(event => {
                const laneKey = `${event.installationId}_${event.modelId}_${event.deviceId}`;
                if (!lanes[laneKey]) {
                    const installation = event.installationId || 'Unknown';
                    lanes[laneKey] = {
                        name: `${event.modelId} (${event.deviceId})`,
                        installationId: installation,
                        events: [],
                        hasValveSpans: false // Track if this lane has valve position events
                    };
                }
                lanes[laneKey].events.push(event);
            });

            // Process each lane to create state spans with valve position awareness
            Object.values(lanes).forEach(lane => {
                lane.spans = [];
                lane.valveSpans = []; // Separate spans for valve positions
                const activeStates = {}; // Track active states by error code
                const activeValveStates = {}; // Track active valve position states separately
                let currentValvePosition = null; // Track 4/3-way valve position

                lane.events.forEach(event => {
                    const code = event.errorCode;
                    if (!code) return;

                    // Define valve position codes
                    const isValveCode = (c) => {
                        return c && (
                            (c >= 'S.112' && c <= 'S.118') ||
                            (c >= 'S.134' && c <= 'S.136')
                        );
                    };

                    // Handle valve position changes (all valve-related codes)
                    const valvePositionMap = {
                        'S.112': 'init',        // Initialisierung
                        'S.113': 'switching-ww', // Schaltet -> Trinkwasser
                        'S.114': 'switching-hk1', // Schaltet -> Heiz-/K√ºhlkreis 1
                        'S.115': 'warmwater',   // Position Trinkwasser
                        'S.116': 'heating-hk1', // Position Heiz-/K√ºhlkreis 1
                        'S.117': 'heating-hk2', // Position Heiz-/K√ºhlkreis 2
                        'S.118': 'buffer',      // Position Pufferspeicher
                        'S.134': 'idle',        // Leerlauf
                        'S.135': 'defrost',     // Abtauen
                        'S.136': 'room'         // Raumbeheizung/Raumk√ºhlung
                    };

                    // Separate handling for valve position codes
                    if (isValveCode(code)) {
                        lane.hasValveSpans = true;

                        if (event.active === true) {
                            // Start of a new valve state
                            activeValveStates[code] = {
                                startTime: event.eventTimestamp || event.createdAt,
                                startEvent: event
                            };
                        } else if (event.active === false) {
                            // End of a valve state
                            if (activeValveStates[code]) {
                                lane.valveSpans.push({
                                    code: code,
                                    startTime: activeValveStates[code].startTime,
                                    endTime: event.eventTimestamp || event.createdAt,
                                    startEvent: activeValveStates[code].startEvent,
                                    endEvent: event
                                });
                                delete activeValveStates[code];
                            }
                        } else if (event.active === null || event.active === undefined) {
                            // Fallback: Treat events without active field as instant events
                            const eventTime = event.eventTimestamp || event.createdAt;
                            const endTime = new Date(new Date(eventTime).getTime() + 5 * 60 * 1000).toISOString();
                            lane.valveSpans.push({
                                code: code,
                                startTime: eventTime,
                                endTime: endTime,
                                startEvent: event,
                                endEvent: null,
                                fallback: true
                            });
                        }
                    }

                    // Only continue with non-valve code processing below
                    if (valvePositionMap[code]) {
                        if (event.active === true) {
                            const newValvePosition = valvePositionMap[code];
                            const eventTime = event.eventTimestamp || event.createdAt;

                            // Migration: If S.125 is already running when valve switches to warmwater
                            if (code === 'S.115' && activeStates['S.125']) {
                                // DON'T end the S.125 span - it continues in the background
                                // Instead, start a S.125-WARMWATER span as an overlay
                                // The original S.125 continues and will be ended when S.125 BEENDET event arrives
                                activeStates['S.125-WARMWATER'] = {
                                    startTime: eventTime,
                                    startEvent: event,
                                    originalCode: 'S.125',
                                    valvePosition: 'warmwater',
                                    parentS125: activeStates['S.125']  // Reference to parent heating state
                                };
                            }

                            // Migration: If S.125-WARMWATER is active when valve switches away from warmwater
                            // This applies to heating circuits (S.116, S.117), puffer (S.118), defrost (S.135), room (S.136), idle (S.134)
                            if (activeStates['S.125-WARMWATER'] && (code === 'S.116' || code === 'S.117' || code === 'S.118' || code === 'S.134' || code === 'S.135' || code === 'S.136')) {
                                // End the S.125-WARMWATER span (the overlay)
                                lane.spans.push({
                                    code: 'S.125-WARMWATER',
                                    originalCode: 'S.125',
                                    startTime: activeStates['S.125-WARMWATER'].startTime,
                                    endTime: eventTime,
                                    startEvent: activeStates['S.125-WARMWATER'].startEvent,
                                    endEvent: event,
                                    valvePosition: 'warmwater'
                                });

                                // Parent S.125 continues - don't create a new span, just track valve position
                                // The background S.125 continues until its actual BEENDET event
                                currentValvePosition = newValvePosition;

                                delete activeStates['S.125-WARMWATER'];
                            }

                            currentValvePosition = newValvePosition;
                        } else if (event.active === false) {
                            const eventTime = event.eventTimestamp || event.createdAt;

                            // When warmwater valve ends, end the S.125-WARMWATER overlay span
                            if (code === 'S.115' && activeStates['S.125-WARMWATER']) {
                                // End the S.125-WARMWATER overlay span
                                lane.spans.push({
                                    code: 'S.125-WARMWATER',
                                    originalCode: 'S.125',
                                    startTime: activeStates['S.125-WARMWATER'].startTime,
                                    endTime: eventTime,
                                    startEvent: activeStates['S.125-WARMWATER'].startEvent,
                                    endEvent: event,
                                    valvePosition: 'warmwater'
                                });

                                delete activeStates['S.125-WARMWATER'];
                                // Parent S.125 continues - don't do anything
                                currentValvePosition = null;
                            }

                            // When heating circuit valve ends, just track the position change
                            if ((code === 'S.116' || code === 'S.117' || code === 'S.118' || code === 'S.134' || code === 'S.135' || code === 'S.136')) {
                                // S.125 continues in the background, just update valve position
                                currentValvePosition = null;
                            }
                        }
                    }

                    // Map S.125 based on valve position
                    let effectiveCode = code;
                    if (code === 'S.125' && currentValvePosition === 'warmwater') {
                        effectiveCode = 'S.125-WARMWATER'; // Virtual code for heating during hot water mode
                    }

                    if (event.active === true) {
                        // Start of a new state
                        activeStates[effectiveCode] = {
                            startTime: event.eventTimestamp || event.createdAt,
                            startEvent: event,
                            originalCode: code,
                            valvePosition: currentValvePosition
                        };
                    } else if (event.active === false) {
                        // End of a state
                        if (activeStates[effectiveCode]) {
                            lane.spans.push({
                                code: effectiveCode,
                                originalCode: code,
                                startTime: activeStates[effectiveCode].startTime,
                                endTime: event.eventTimestamp || event.createdAt,
                                startEvent: activeStates[effectiveCode].startEvent,
                                endEvent: event,
                                valvePosition: activeStates[effectiveCode].valvePosition
                            });
                            delete activeStates[effectiveCode];
                        }
                    } else if (event.active === null || event.active === undefined) {
                        // Fallback: Treat events without active field as instant events with minimum duration
                        const eventTime = event.eventTimestamp || event.createdAt;
                        const endTime = new Date(new Date(eventTime).getTime() + 5 * 60 * 1000).toISOString(); // 5 min default duration
                        lane.spans.push({
                            code: effectiveCode,
                            originalCode: code,
                            startTime: eventTime,
                            endTime: endTime,
                            startEvent: event,
                            endEvent: null,
                            fallback: true,
                            valvePosition: currentValvePosition
                        });
                    }
                });

                // Add ongoing states (still active)
                Object.entries(activeStates).forEach(([effectiveCode, state]) => {
                    lane.spans.push({
                        code: effectiveCode,
                        originalCode: state.originalCode,
                        startTime: state.startTime,
                        endTime: new Date().toISOString(), // Current time
                        startEvent: state.startEvent,
                        endEvent: null,
                        ongoing: true,
                        valvePosition: state.valvePosition
                    });
                });

                // Add ongoing valve states (still active)
                Object.entries(activeValveStates).forEach(([code, state]) => {
                    lane.valveSpans.push({
                        code: code,
                        startTime: state.startTime,
                        endTime: new Date().toISOString(), // Current time
                        startEvent: state.startEvent,
                        endEvent: null,
                        ongoing: true
                    });
                });

                // Sort spans by start time, then by end time to ensure correct ordering
                lane.spans.sort((a, b) => {
                    const aStart = new Date(a.startTime).getTime();
                    const bStart = new Date(b.startTime).getTime();
                    if (aStart !== bStart) return aStart - bStart;
                    return new Date(a.endTime).getTime() - new Date(b.endTime).getTime();
                });

                // Post-process spans to fix gaps caused by state transitions at same timestamp
                // When one span ends at time T and another starts at time T, adjust the end time
                // of the first span to match the start time of the next to avoid gaps
                for (let i = 0; i < lane.spans.length - 1; i++) {
                    const currentSpan = lane.spans[i];
                    const nextSpan = lane.spans[i + 1];

                    // Check if next span starts exactly when current span ends
                    const currentEnd = new Date(currentSpan.endTime).getTime();
                    const nextStart = new Date(nextSpan.startTime).getTime();

                    // If there's a tiny gap (less than 1 second), extend current span to match next start
                    if (nextStart > currentEnd && nextStart - currentEnd < 1000) {
                        currentSpan.endTime = nextSpan.startTime;
                    }
                }

                // Same for valve spans
                for (let i = 0; i < lane.valveSpans.length - 1; i++) {
                    const currentSpan = lane.valveSpans[i];
                    const nextSpan = lane.valveSpans[i + 1];

                    const currentEnd = new Date(currentSpan.endTime).getTime();
                    const nextStart = new Date(nextSpan.startTime).getTime();

                    if (nextStart > currentEnd && nextStart - currentEnd < 1000) {
                        currentSpan.endTime = nextSpan.startTime;
                    }
                }
            });

            const laneArray = Object.values(lanes);

            // Calculate timeline dimensions based on number of lanes and screen size
            const isMobile = window.innerWidth <= 768;
            const containerWidth = container.offsetWidth || window.innerWidth;
            const minWidth = isMobile ? containerWidth - 40 : 1400;
            const width = Math.max(minWidth, sortedEvents.length * (isMobile ? 3 : 6));

            // Define margins first
            const margin = { top: 30, right: isMobile ? 20 : 40, bottom: 70, left: isMobile ? 120 : 280 };

            // Calculate total lane units (main lanes + valve sub-lanes)
            const totalLaneUnits = laneArray.reduce((sum, lane) => {
                return sum + 1 + (lane.hasValveSpans ? 0.35 : 0); // 1 main lane + 0.35 smaller valve lane if needed
            }, 0);

            // Design: Card-based layout with adequate space per device
            // Each device gets a card with valve position + event timeline
            let minMainLaneHeight;
            if (isMobile) {
                minMainLaneHeight = 60;
            } else {
                // Generous height per device for good readability
                minMainLaneHeight = 120; // Each device gets 120px for great readability
            }

            // Add padding for device card margins and headers
            const deviceCardMargin = 20; // Space between device cards
            const deviceCardPadding = 15; // Padding inside each card
            const deviceCardHeaderHeight = 35; // Height for device name header

            // Calculate total height
            const minHeight = margin.top + margin.bottom +
                             (laneArray.length * (minMainLaneHeight + deviceCardMargin + deviceCardHeaderHeight)) +
                             (laneArray.length * deviceCardPadding * 2) + 40;
            const height = minHeight;

            // Calculate average lane height based on total lanes
            const totalLaneSpace = height - margin.top - margin.bottom;
            const averageLaneHeight = totalLaneSpace / Math.max(totalLaneUnits, 1);

            // Create scale
            const xScale = (date) => {
                const t = (new Date(date) - timeExtent[0]) / (timeExtent[1] - timeExtent[0]);
                return margin.left + t * (width - margin.left - margin.right);
            };

            // Create SVG (height will be adjusted after rendering all lanes)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.style.display = 'block';
            container.appendChild(svg);

            // Draw grid and time axis with intelligent intervals (will be drawn after lanes)
            const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Calculate appropriate interval based on time range
            const timeRangeHours = (timeExtent[1] - timeExtent[0]) / (1000 * 60 * 60);
            let hourInterval;
            if (timeRangeHours <= 24) {
                hourInterval = 1; // Every hour for <= 24h
            } else if (timeRangeHours <= 48) {
                hourInterval = 2; // Every 2 hours for <= 48h
            } else if (timeRangeHours <= 96) {
                hourInterval = 3; // Every 3 hours for <= 4 days
            } else if (timeRangeHours <= 168) {
                hourInterval = 6; // Every 6 hours for <= 7 days
            } else if (timeRangeHours <= 336) {
                hourInterval = 12; // Every 12 hours for <= 14 days
            } else {
                hourInterval = 24; // Every day for > 14 days
            }

            // Round start time to previous full hour
            const axisStartTime = new Date(timeExtent[0]);
            axisStartTime.setMinutes(0, 0, 0);

            // Generate rounded hour marks
            const timeMarks = [];
            let axisCurrentTime = new Date(axisStartTime);
            while (axisCurrentTime <= timeExtent[1]) {
                if (axisCurrentTime >= timeExtent[0]) {
                    timeMarks.push(new Date(axisCurrentTime));
                }
                axisCurrentTime.setHours(axisCurrentTime.getHours() + hourInterval);
            }

            // Store axis drawing function for later (after lanes are rendered)
            const drawAxisFn = (finalHeight) => {
                // Draw grid lines and labels for each time mark
                timeMarks.forEach((markTime, index) => {
                    const x = xScale(markTime);
                    const isFirst = index === 0;
                    const isLast = index === timeMarks.length - 1;

                    // Grid line
                    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    gridLine.setAttribute('x1', x);
                    gridLine.setAttribute('y1', margin.top);
                    gridLine.setAttribute('x2', x);
                    gridLine.setAttribute('y2', finalHeight - margin.bottom);
                    gridLine.setAttribute('stroke', 'rgba(255,255,255,0.05)');
                    gridLine.setAttribute('stroke-width', '1');
                    if (isFirst || isLast) {
                        gridLine.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                        gridLine.setAttribute('stroke-width', '2');
                    }
                    axisGroup.appendChild(gridLine);

                    // Tick
                    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tick.setAttribute('x1', x);
                    tick.setAttribute('y1', finalHeight - margin.bottom);
                    tick.setAttribute('x2', x);
                    tick.setAttribute('y2', finalHeight - margin.bottom + 6);
                    tick.setAttribute('stroke', 'rgba(255,255,255,0.3)');
                    tick.setAttribute('stroke-width', '2');
                    axisGroup.appendChild(tick);

                    // Time label - show date and time for intervals >= 12h, otherwise just time
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x);
                    label.setAttribute('y', finalHeight - margin.bottom + 22);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', isMobile ? '9' : '11');
                label.setAttribute('font-weight', '500');
                label.setAttribute('fill', '#a0a0b0');

                let labelText;
                if (hourInterval >= 12) {
                    // Show date and time for long intervals
                    labelText = markTime.toLocaleString('de-DE', {
                        day: '2-digit',
                        month: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } else {
                    // Show only time for short intervals
                    labelText = markTime.toLocaleString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
                label.textContent = labelText;
                axisGroup.appendChild(label);

                // Date label (only for intervals < 12h and on midnight or every 4th mark)
                if (hourInterval < 12 && (markTime.getHours() === 0 || index % 4 === 0)) {
                    const dateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    dateLabel.setAttribute('x', x);
                    dateLabel.setAttribute('y', finalHeight - margin.bottom + 38);
                    dateLabel.setAttribute('text-anchor', 'middle');
                    dateLabel.setAttribute('font-size', '10');
                    dateLabel.setAttribute('fill', '#707080');
                    dateLabel.textContent = markTime.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: 'short' });
                    axisGroup.appendChild(dateLabel);
                    }
                });
            };

            // Draw lanes and state spans (before axis so axis is on top)
            let currentYOffset = margin.top;

            laneArray.forEach((lane, laneIdx) => {
                // Card-based layout: fixed heights per device card
                const cardEventHeight = minMainLaneHeight; // Event timeline height
                const cardValveHeight = lane.hasValveSpans ? minMainLaneHeight * 0.25 : 0; // Valve lane (25% of event height)
                const valveSpacing = lane.hasValveSpans ? 8 : 0; // Nice spacing between valve and event
                const cardPadding = deviceCardPadding;

                // Calculate main and valve lane heights for this device
                const mainLaneHeight = cardEventHeight;
                const valveLaneHeight = cardValveHeight;
                const cardTotalHeight = deviceCardHeaderHeight + cardPadding + valveLaneHeight + valveSpacing + cardEventHeight + cardPadding;

                // Card header start
                const cardHeaderY = currentYOffset;
                const cardContentStartY = cardHeaderY + deviceCardHeaderHeight;

                // Valve lane comes FIRST (above events), with padding
                const yValve = cardContentStartY + cardPadding;
                const y = yValve + valveLaneHeight + valveSpacing; // Events below valve lane

                // Combined height for main + valve lanes
                const totalMainHeight = valveLaneHeight + valveSpacing + mainLaneHeight;

                // ===== DEVICE CARD BACKGROUND =====
                const cardBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                cardBg.setAttribute('x', 5);
                cardBg.setAttribute('y', cardHeaderY);
                cardBg.setAttribute('width', width - 10);
                cardBg.setAttribute('height', cardTotalHeight);
                cardBg.setAttribute('fill', 'rgba(255,255,255,0.04)');
                cardBg.setAttribute('stroke', 'rgba(255,255,255,0.12)');
                cardBg.setAttribute('stroke-width', '1');
                cardBg.setAttribute('rx', '8');
                svg.appendChild(cardBg);

                // ===== DEVICE CARD HEADER =====
                const headerBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                headerBg.setAttribute('x', 5);
                headerBg.setAttribute('y', cardHeaderY);
                headerBg.setAttribute('width', width - 10);
                headerBg.setAttribute('height', deviceCardHeaderHeight);
                headerBg.setAttribute('fill', 'rgba(139, 92, 246, 0.15)');
                headerBg.setAttribute('stroke', 'none');
                headerBg.setAttribute('rx', '8');
                svg.appendChild(headerBg);

                // Device name in header
                const headerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                headerText.setAttribute('x', margin.left);
                headerText.setAttribute('y', cardHeaderY + deviceCardHeaderHeight / 2);
                headerText.setAttribute('dominant-baseline', 'middle');
                headerText.setAttribute('font-size', isMobile ? '12' : '14');
                headerText.setAttribute('fill', '#c7d2ff');
                headerText.setAttribute('font-weight', '700');
                const installation = installations[lane.installationId];
                headerText.textContent = `${lane.name}${installation && installation.location ? ` ‚Ä¢ ${installation.location}` : ''}`;
                svg.appendChild(headerText);

                // Lane background for event area
                const laneBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                laneBg.setAttribute('x', margin.left);
                laneBg.setAttribute('y', y - 2);
                laneBg.setAttribute('width', width - margin.left - margin.right);
                laneBg.setAttribute('height', mainLaneHeight + 4);
                laneBg.setAttribute('fill', 'rgba(255,255,255,0.02)');
                laneBg.setAttribute('rx', '4');
                svg.appendChild(laneBg);

                // If has valve spans, create separate labels for valve and event lanes
                if (lane.hasValveSpans) {
                    // Valve lane label background
                    const valveLabelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    valveLabelBg.setAttribute('x', 10);
                    valveLabelBg.setAttribute('y', yValve + valveLaneHeight / 2 - 12);
                    valveLabelBg.setAttribute('width', margin.left - 20);
                    valveLabelBg.setAttribute('height', 24);
                    valveLabelBg.setAttribute('fill', 'rgba(255,255,255,0.03)');
                    valveLabelBg.setAttribute('stroke', 'rgba(255,255,255,0.08)');
                    valveLabelBg.setAttribute('stroke-width', '0.5');
                    valveLabelBg.setAttribute('rx', '4');
                    svg.appendChild(valveLabelBg);

                    // Valve lane label
                    const valveLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    valveLabel.setAttribute('x', margin.left - 15);
                    valveLabel.setAttribute('y', yValve + valveLaneHeight / 2);
                    valveLabel.setAttribute('text-anchor', 'end');
                    valveLabel.setAttribute('dominant-baseline', 'middle');
                    valveLabel.setAttribute('font-size', isMobile ? '8' : '9');
                    valveLabel.setAttribute('fill', '#888898');
                    valveLabel.setAttribute('font-weight', '400');
                    valveLabel.textContent = 'üîÄ V-Pos';
                    svg.appendChild(valveLabel);

                    // Event lane label background
                    const eventLabelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    eventLabelBg.setAttribute('x', 10);
                    eventLabelBg.setAttribute('y', y + mainLaneHeight / 2 - 30);
                    eventLabelBg.setAttribute('width', margin.left - 20);
                    eventLabelBg.setAttribute('height', 60);
                    eventLabelBg.setAttribute('fill', 'rgba(255,255,255,0.05)');
                    eventLabelBg.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                    eventLabelBg.setAttribute('stroke-width', '1');
                    eventLabelBg.setAttribute('rx', '6');
                    svg.appendChild(eventLabelBg);

                    // Event lane label (device name + location)
                    const eventLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    eventLabel.setAttribute('x', margin.left - 15);
                    eventLabel.setAttribute('y', y + mainLaneHeight / 2);
                    eventLabel.setAttribute('text-anchor', 'end');
                    eventLabel.setAttribute('fill', '#e0e0e0');

                    // Line 1: Device name
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    line1.setAttribute('x', margin.left - 15);
                    line1.setAttribute('dy', '-0.6em');
                    line1.setAttribute('font-size', isMobile ? '9' : '11');
                    line1.setAttribute('font-weight', '600');
                    line1.textContent = lane.name;
                    eventLabel.appendChild(line1);

                    // Line 2: Installation location (skip on mobile to save space)
                    if (!isMobile && installation && installation.location) {
                        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        line2.setAttribute('x', margin.left - 15);
                        line2.setAttribute('dy', '1.2em');
                        line2.setAttribute('font-size', '10');
                        line2.setAttribute('fill', '#a0a0b0');
                        line2.setAttribute('font-weight', '400');
                        line2.textContent = `üìç ${installation.location}`;
                        eventLabel.appendChild(line2);
                    }

                    svg.appendChild(eventLabel);
                } else {
                    // No valve spans - single label for event lane
                    const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    labelBg.setAttribute('x', 10);
                    labelBg.setAttribute('y', y + mainLaneHeight / 2 - 20);
                    labelBg.setAttribute('width', margin.left - 20);
                    labelBg.setAttribute('height', 40);
                    labelBg.setAttribute('fill', 'rgba(255,255,255,0.05)');
                    labelBg.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                    labelBg.setAttribute('stroke-width', '1');
                    labelBg.setAttribute('rx', '6');
                    svg.appendChild(labelBg);

                    const laneLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    laneLabel.setAttribute('x', margin.left - 15);
                    laneLabel.setAttribute('y', y + mainLaneHeight / 2);
                    laneLabel.setAttribute('text-anchor', 'end');
                    laneLabel.setAttribute('fill', '#e0e0e0');

                    // Line 1: Device name
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    line1.setAttribute('x', margin.left - 15);
                    line1.setAttribute('dy', '-0.6em');
                    line1.setAttribute('font-size', isMobile ? '9' : '11');
                    line1.setAttribute('font-weight', '600');
                    line1.textContent = lane.name;
                    laneLabel.appendChild(line1);

                    // Line 2: Installation location (skip on mobile to save space)
                    if (!isMobile && installation && installation.location) {
                        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        line2.setAttribute('x', margin.left - 15);
                        line2.setAttribute('dy', '1.2em');
                        line2.setAttribute('font-size', '10');
                        line2.setAttribute('fill', '#a0a0b0');
                        line2.setAttribute('font-weight', '400');
                        line2.textContent = `üìç ${installation.location}`;
                        laneLabel.appendChild(line2);
                    }

                    svg.appendChild(laneLabel);
                }

                // Draw state spans (duration bars)
                lane.spans.forEach((span, spanIdx) => {
                    // Apply timeline filter: only render spans that should be displayed
                    if (globalFilters.timelineTypes[span.code] === false) {
                        return; // Skip this span
                    }

                    // Skip valve position codes - they go in separate valve lane
                    const isValveCode = (c) => {
                        return c && (
                            (c >= 'S.112' && c <= 'S.118') ||
                            (c >= 'S.134' && c <= 'S.136')
                        );
                    };
                    if (isValveCode(span.code)) {
                        return; // Skip valve codes - they are rendered in valve lane
                    }

                    // Check if this span type has a visual representation
                    const eventInfo = eventTypes[span.code];
                    if (!eventInfo) {
                        return; // Skip spans without visual definition (e.g., raw valve position events)
                    }

                    const x1 = xScale(span.startTime);
                    const x2 = xScale(span.endTime);
                    const actualWidth = x2 - x1;
                    const spanWidth = Math.max(actualWidth, 2); // Minimum 2px width, but we'll use visual tricks for very small spans

                    const color = eventInfo?.color || '#6b7280';
                    const gradient = eventInfo?.gradient || color;

                    // Calculate bar dimensions
                    // S.125-WARMWATER (warmwater overlay) should be smaller to show heating bar underneath
                    let barHeight, barY;
                    if (span.code === 'S.125-WARMWATER') {
                        // Warmwater overlay: 75% of lane height, leaving visible space for heating bar above/below
                        barHeight = Math.max(mainLaneHeight * 0.75, 12);
                        barY = y + (mainLaneHeight - barHeight) / 2;
                    } else {
                        // Regular spans: full height minus padding for nice presentation
                        barHeight = Math.max(mainLaneHeight - 20, 20); // Minimum 20px bar height
                        barY = y + (mainLaneHeight - barHeight) / 2; // Center bar vertically in lane
                    }

                    // Shadow/glow effect
                    const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shadow.setAttribute('x', x1 - 1);
                    shadow.setAttribute('y', barY - 2);
                    shadow.setAttribute('width', spanWidth + 2);
                    shadow.setAttribute('height', barHeight + 4);
                    shadow.setAttribute('fill', color);
                    shadow.setAttribute('opacity', '0.2');
                    shadow.setAttribute('rx', '6');
                    shadow.setAttribute('filter', 'blur(4px)');
                    svg.appendChild(shadow);

                    // Create gradient definition
                    const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    if (!svg.querySelector('defs')) svg.appendChild(defs);

                    const gradientId = `gradient-${laneIdx}-${spanIdx}`;
                    const gradDef = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                    gradDef.setAttribute('id', gradientId);
                    gradDef.setAttribute('x1', '0%');
                    gradDef.setAttribute('y1', '0%');
                    gradDef.setAttribute('x2', '0%');
                    gradDef.setAttribute('y2', '100%');

                    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', color);
                    stop1.setAttribute('stop-opacity', '0.95');

                    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop2.setAttribute('offset', '100%');
                    stop2.setAttribute('stop-color', color);
                    stop2.setAttribute('stop-opacity', '0.75');

                    gradDef.appendChild(stop1);
                    gradDef.appendChild(stop2);
                    defs.appendChild(gradDef);

                    // Main state span bar
                    const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    bar.setAttribute('x', x1);
                    bar.setAttribute('y', barY);
                    bar.setAttribute('width', spanWidth);
                    bar.setAttribute('height', barHeight);
                    bar.setAttribute('fill', `url(#${gradientId})`);
                    bar.setAttribute('rx', '6');
                    if (span.fallback) {
                        bar.setAttribute('stroke', 'rgba(255,255,255,0.4)');
                        bar.setAttribute('stroke-width', '1');
                        bar.setAttribute('stroke-dasharray', '4,2');
                        bar.setAttribute('opacity', '0.7');
                    }
                    bar.style.cursor = 'pointer';
                    bar.style.transition = 'all 0.2s';

                    // Hover effect
                    bar.addEventListener('mouseenter', function() {
                        this.setAttribute('opacity', '1');
                        this.setAttribute('stroke', 'rgba(255,255,255,0.5)');
                        this.setAttribute('stroke-width', '2');
                    });
                    bar.addEventListener('mouseleave', function() {
                        this.removeAttribute('opacity');
                        this.removeAttribute('stroke');
                        this.removeAttribute('stroke-width');
                    });

                    // Calculate duration
                    const duration = (new Date(span.endTime) - new Date(span.startTime)) / 1000 / 60; // minutes
                    const durationText = duration < 60
                        ? `${Math.round(duration)}min`
                        : `${(duration / 60).toFixed(1)}h`;

                    // Tooltip with additional context for warmwater heating
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    const startTime = new Date(span.startTime).toLocaleString('de-DE');
                    const endTime = span.ongoing ? 'Noch aktiv ‚è≥' : new Date(span.endTime).toLocaleString('de-DE');
                    let tooltipText = `${eventInfo?.icon || ''} ${eventInfo?.label || span.code}`;
                    if (span.code === 'S.125-WARMWATER') {
                        tooltipText += '\n(W√§rmepumpe heizt bei Ventilstellung Warmwasser)';
                    }
                    if (span.fallback) {
                        tooltipText += '\n‚ö†Ô∏è Gesch√§tzte Dauer (Event ohne Start/Ende)';
                    }
                    tooltipText += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nStart: ${startTime}\nEnde: ${endTime}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nDauer: ${durationText}`;
                    title.textContent = tooltipText;
                    bar.appendChild(title);

                    svg.appendChild(bar);

                    // Add icon and duration label if span is wide enough
                    const labelY = barY + barHeight / 2;
                    const minWidthForLabel = isMobile ? 40 : 60;
                    const minWidthForMini = isMobile ? 20 : 30;

                    if (spanWidth > minWidthForLabel) {
                        const iconLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        iconLabel.setAttribute('x', x1 + (isMobile ? 4 : 8));
                        iconLabel.setAttribute('y', labelY - (isMobile ? 4 : 6));
                        iconLabel.setAttribute('font-size', isMobile ? '10' : '14');
                        iconLabel.textContent = eventInfo?.icon || '';
                        svg.appendChild(iconLabel);

                        const durationLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        durationLabel.setAttribute('x', x1 + spanWidth / 2);
                        durationLabel.setAttribute('y', labelY);
                        durationLabel.setAttribute('text-anchor', 'middle');
                        durationLabel.setAttribute('dominant-baseline', 'middle');
                        durationLabel.setAttribute('font-size', isMobile ? '9' : '11');
                        durationLabel.setAttribute('fill', 'white');
                        durationLabel.setAttribute('font-weight', '700');
                        durationLabel.setAttribute('style', 'text-shadow: 0 1px 3px rgba(0,0,0,0.5);');
                        durationLabel.textContent = durationText;
                        svg.appendChild(durationLabel);
                    } else if (spanWidth > minWidthForMini) {
                        const miniLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        miniLabel.setAttribute('x', x1 + spanWidth / 2);
                        miniLabel.setAttribute('y', labelY);
                        miniLabel.setAttribute('text-anchor', 'middle');
                        miniLabel.setAttribute('dominant-baseline', 'middle');
                        miniLabel.setAttribute('font-size', isMobile ? '7' : '9');
                        miniLabel.setAttribute('fill', 'white');
                        miniLabel.setAttribute('font-weight', '700');
                        miniLabel.textContent = durationText;
                        svg.appendChild(miniLabel);
                    }

                    // Shine effect on top
                    const shine = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shine.setAttribute('x', x1);
                    shine.setAttribute('y', barY);
                    shine.setAttribute('width', spanWidth);
                    shine.setAttribute('height', barHeight / 3);
                    shine.setAttribute('fill', 'rgba(255,255,255,0.15)');
                    shine.setAttribute('rx', '6');
                    svg.appendChild(shine);
                });

                // Draw event markers (circles at start/end) with glow
                lane.events.forEach(event => {
                    const eventTime = event.eventTimestamp || event.createdAt;
                    const x = xScale(eventTime);
                    const color = eventTypes[event.errorCode]?.color || '#6b7280';

                    // Outer glow
                    const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    glow.setAttribute('cx', x);
                    glow.setAttribute('cy', y + mainLaneHeight / 2);
                    glow.setAttribute('r', 5);
                    glow.setAttribute('fill', color);
                    glow.setAttribute('opacity', '0.3');
                    svg.appendChild(glow);

                    // Main circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y + mainLaneHeight / 2);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', event.active ? color : 'rgba(30, 30, 46, 0.9)');
                    circle.setAttribute('stroke', color);
                    circle.setAttribute('stroke-width', event.active ? '2' : '2');
                    svg.appendChild(circle);

                    // Inner highlight
                    if (event.active) {
                        const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        highlight.setAttribute('cx', x - 1);
                        highlight.setAttribute('cy', y + mainLaneHeight / 2 - 1);
                        highlight.setAttribute('r', 1.5);
                        highlight.setAttribute('fill', 'rgba(255,255,255,0.6)');
                        svg.appendChild(highlight);
                    }
                });

                // Draw valve position spans (smaller, thin bars ABOVE main events in visual space)
                // Rendered AFTER events so they appear on top in SVG but positioned above event lane
                if (lane.hasValveSpans && valveLaneHeight > 0) {
                    lane.valveSpans.forEach((span, spanIdx) => {
                        // Apply timeline filter: only render spans that should be displayed
                        if (globalFilters.timelineTypes[span.code] === false) {
                            return; // Skip this span
                        }

                        // Check if this span type has a visual representation
                        const eventInfo = eventTypes[span.code];
                        if (!eventInfo) {
                            return; // Skip spans without visual definition
                        }

                        const x1 = xScale(span.startTime);
                        const x2 = xScale(span.endTime);
                        const actualWidth = x2 - x1;
                        const spanWidth = Math.max(actualWidth, 2); // Minimum 2px width

                        const color = eventInfo?.color || '#6b7280';

                        // Calculate bar dimensions for valve lane (smaller than main lane)
                        const valveBarHeight = Math.max(valveLaneHeight - 8, 8); // Thinner bars for valve lane
                        const valveBarY = yValve + (valveLaneHeight - valveBarHeight) / 2; // Center bar vertically in valve lane

                        // Shadow/glow effect
                        const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        shadow.setAttribute('x', x1 - 1);
                        shadow.setAttribute('y', valveBarY - 1);
                        shadow.setAttribute('width', spanWidth + 2);
                        shadow.setAttribute('height', valveBarHeight + 2);
                        shadow.setAttribute('fill', color);
                        shadow.setAttribute('opacity', '0.15');
                        shadow.setAttribute('rx', '3');
                        shadow.setAttribute('filter', 'blur(2px)');
                        svg.appendChild(shadow);

                        // Create gradient definition for valve bar
                        const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        if (!svg.querySelector('defs')) svg.appendChild(defs);

                        const gradientId = `gradient-valve-${laneIdx}-${spanIdx}`;
                        const gradDef = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradDef.setAttribute('id', gradientId);
                        gradDef.setAttribute('x1', '0%');
                        gradDef.setAttribute('y1', '0%');
                        gradDef.setAttribute('x2', '0%');
                        gradDef.setAttribute('y2', '100%');

                        const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                        stop1.setAttribute('offset', '0%');
                        stop1.setAttribute('stop-color', color);
                        stop1.setAttribute('stop-opacity', '0.7');

                        const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                        stop2.setAttribute('offset', '100%');
                        stop2.setAttribute('stop-color', color);
                        stop2.setAttribute('stop-opacity', '0.5');

                        gradDef.appendChild(stop1);
                        gradDef.appendChild(stop2);
                        defs.appendChild(gradDef);

                        // Main valve span bar
                        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bar.setAttribute('x', x1);
                        bar.setAttribute('y', valveBarY);
                        bar.setAttribute('width', spanWidth);
                        bar.setAttribute('height', valveBarHeight);
                        bar.setAttribute('fill', `url(#${gradientId})`);
                        bar.setAttribute('rx', '3');
                        if (span.fallback) {
                            bar.setAttribute('stroke', 'rgba(255,255,255,0.3)');
                            bar.setAttribute('stroke-width', '0.5');
                            bar.setAttribute('stroke-dasharray', '3,2');
                            bar.setAttribute('opacity', '0.6');
                        }
                        bar.style.cursor = 'pointer';
                        bar.style.transition = 'all 0.2s';

                        // Hover effect
                        bar.addEventListener('mouseenter', function() {
                            this.setAttribute('opacity', '0.9');
                            this.setAttribute('stroke', 'rgba(255,255,255,0.4)');
                            this.setAttribute('stroke-width', '1');
                        });
                        bar.addEventListener('mouseleave', function() {
                            this.removeAttribute('opacity');
                            if (!span.fallback) {
                                this.removeAttribute('stroke');
                                this.removeAttribute('stroke-width');
                            }
                        });

                        // Calculate duration
                        const duration = (new Date(span.endTime) - new Date(span.startTime)) / 1000 / 60; // minutes
                        const durationText = duration < 60
                            ? `${Math.round(duration)}min`
                            : `${(duration / 60).toFixed(1)}h`;

                        // Tooltip
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        const startTime = new Date(span.startTime).toLocaleString('de-DE');
                        const endTime = span.ongoing ? 'Noch aktiv ‚è≥' : new Date(span.endTime).toLocaleString('de-DE');
                        let tooltipText = `${eventInfo?.icon || ''} ${eventInfo?.label || span.code}`;
                        if (span.fallback) {
                            tooltipText += '\n‚ö†Ô∏è Gesch√§tzte Dauer (Event ohne Start/Ende)';
                        }
                        tooltipText += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nStart: ${startTime}\nEnde: ${endTime}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nDauer: ${durationText}`;
                        title.textContent = tooltipText;
                        bar.appendChild(title);

                        svg.appendChild(bar);

                        // Add icon if span is wide enough
                        const labelY = valveBarY + valveBarHeight / 2;
                        const minWidthForIcon = 25;

                        if (spanWidth > minWidthForIcon) {
                            const iconLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            iconLabel.setAttribute('x', x1 + 2);
                            iconLabel.setAttribute('y', labelY - 1);
                            iconLabel.setAttribute('font-size', '10');
                            iconLabel.textContent = eventInfo?.icon || '';
                            svg.appendChild(iconLabel);
                        }
                    });
                }

                // Update offset for next device card
                currentYOffset += cardTotalHeight + deviceCardMargin;
            });

            // Set the final SVG height based on actual lane content
            const finalHeight = currentYOffset + margin.bottom;
            svg.setAttribute('height', finalHeight);

            // Now draw the axis on top
            drawAxisFn(finalHeight);
            svg.appendChild(axisGroup);

            // ===== ADJUST CONTAINER HEIGHT BASED ON SVG CONTENT =====
            // Set container height to show all content with minimal scrolling
            const timelineDiv = document.querySelector('#timeline');
            const timelineContainer = document.querySelector('.timeline-container');

            if (timelineDiv && timelineContainer) {
                // Set the #timeline div height to match the SVG content
                timelineDiv.style.height = finalHeight + 'px';

                // Use the actual SVG height + some padding for the controls at the top
                const controlsHeight = 80; // Space for title, buttons, filters
                const containerPaddingTotal = 48; // padding: 24px top + 24px bottom
                const totalNeededHeight = finalHeight + controlsHeight + containerPaddingTotal;

                // Set a reasonable max-height, minimum 750px for readability
                const minMaxHeight = 750;
                const dynamicMaxHeight = Math.max(minMaxHeight, totalNeededHeight);

                timelineContainer.style.maxHeight = dynamicMaxHeight + 'px';
                console.log(`Timeline: ${laneArray.length} devices, SVG height ${finalHeight}px, #timeline height ${finalHeight}px, container height ${dynamicMaxHeight}px`);
            }
        }

        // ========================================
        // TIMELINE CONTROLS & PERSISTENCE
        // ========================================

        /**
         * Save timeline filter settings to localStorage
         */
        function saveTimelineFilters() {
            try {
                localStorage.setItem('vicare_timeline_filters', JSON.stringify(globalFilters.timelineTypes));
                // Show success feedback
                const btn = document.getElementById('saveFiltersBtn');
                if (btn) {
                    const originalText = btn.textContent;
                    btn.textContent = '‚úì Gespeichert!';
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)';
                    }, 2000);
                }
            } catch (e) {
                console.error('Failed to save timeline filters:', e);
                alert('Fehler beim Speichern der Filter-Einstellungen');
            }
        }

        /**
         * Load timeline filter settings from localStorage
         */
        function loadTimelineFilters() {
            try {
                const saved = localStorage.getItem('vicare_timeline_filters');
                if (saved) {
                    const savedFilters = JSON.parse(saved);
                    // Merge saved filters with defaults (in case new filters were added)
                    globalFilters.timelineTypes = { ...globalFilters.timelineTypes, ...savedFilters };
                    console.log('Loaded timeline filters from localStorage');
                }
            } catch (e) {
                console.error('Failed to load timeline filters:', e);
            }
        }

        /**
         * Reset timeline filters to defaults
         */
        function resetTimelineFilters() {
            if (confirm('M√∂chtest du alle Timeline-Filter auf die Standardwerte zur√ºcksetzen?')) {
                // Reset to all true
                Object.keys(globalFilters.timelineTypes).forEach(key => {
                    globalFilters.timelineTypes[key] = true;
                });
                // Clear from localStorage
                localStorage.removeItem('vicare_timeline_filters');
                // Re-render timeline
                const filteredEvents = applyFilters(allEvents);
                renderTimeline(filteredEvents);
            }
        }

        /**
         * Toggle timeline event type filter
         */
        function toggleTimelineFilter(code) {
            globalFilters.timelineTypes[code] = !globalFilters.timelineTypes[code];
            // Only re-render timeline, not event list
            const filteredEvents = applyFilters(allEvents);
            renderTimeline(filteredEvents);
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        /**
         * Initialize UI elements with globalFilters values
         */
        function initializeUI() {
            document.getElementById('daysSelect').value = globalFilters.days;
            document.getElementById('deviceSelect').value = globalFilters.device;
            document.getElementById('typeFilter').value = globalFilters.type;
            document.getElementById('filterInput').value = globalFilters.search;
        }

        function openDashboard() {
            // Get selected device from filter
            const deviceSelect = document.getElementById('deviceSelect');
            const selectedValue = deviceSelect.value;

            // Function to navigate to dashboard
            const navigateToDashboard = (installationId, deviceId, gatewaySerial) => {
                let url = `/dashboard?installationId=${installationId}`;
                if (deviceId) url += `&deviceId=${deviceId}`;
                if (gatewaySerial) url += `&gatewaySerial=${gatewaySerial}`;
                window.location.href = url;
            };

            // If "all" is selected or no specific device, get first installation
            if (selectedValue === 'all' || !selectedValue) {
                fetch('/api/devices')
                    .then(response => response.json())
                    .then(devicesByInstall => {
                        if (devicesByInstall.length > 0) {
                            const firstInstall = devicesByInstall[0];
                            // Get first heating device
                            const firstDevice = firstInstall.devices && firstInstall.devices.length > 0
                                ? firstInstall.devices[0]
                                : null;

                            navigateToDashboard(
                                firstInstall.installationId,
                                firstDevice ? firstDevice.deviceId : '0',
                                firstDevice ? firstDevice.gatewaySerial : undefined
                            );
                        } else {
                            alert('Keine Installationen gefunden');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading installations:', error);
                        alert('Fehler beim Laden der Installationen');
                    });
            } else {
                // Parse selected device (format: installationId:deviceId or installationId:gatewaySerial:deviceId)
                const parts = selectedValue.split(':');
                if (parts.length === 2) {
                    // Old format: installationId:deviceId
                    navigateToDashboard(parts[0], parts[1]);
                } else if (parts.length === 3) {
                    // New format: installationId:gatewaySerial:deviceId
                    navigateToDashboard(parts[0], parts[2], parts[1]);
                } else {
                    // Fallback: just navigate to dashboard without specific device
                    window.location.href = '/dashboard';
                }
            }
        }

        // ========================================
        // EXPORT FUNCTION
        // ========================================

        /**
         * Export filtered events as JSON file for debugging
         */
        function exportEvents() {
            const filteredEvents = applyFilters(allEvents);

            if (filteredEvents.length === 0) {
                alert('Keine Events zum Exportieren vorhanden');
                return;
            }

            // Create export data with metadata
            const exportData = {
                exportDate: new Date().toISOString(),
                filters: {
                    days: globalFilters.days,
                    device: globalFilters.device,
                    type: globalFilters.type,
                    search: globalFilters.search
                },
                eventCount: filteredEvents.length,
                events: filteredEvents
            };

            // Convert to JSON with pretty formatting
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.download = `vicare-events-${timestamp}.json`;
            link.href = url;

            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log(`Exported ${filteredEvents.length} events`);
        }

        // Initial load
        window.onload = async () => {
            // Load saved timeline filters from localStorage BEFORE initializing UI
            loadTimelineFilters();
            initializeUI();
            await loadStatus();
            await loadEvents();
        };
    </script>
</body>
</html>